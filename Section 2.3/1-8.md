### 2.3.1 What if `factorial(n)` is called with negative `n`? With `n = 35`?

* **Negative `n`** (for the usual recursive definition `if (n == 0) return 1; else return n * factorial(n-1);`):
  It will keep calling `factorial(n-1)` forever (−1, −2, −3, …), never hits the base case, and eventually throws a **StackOverflowError**.
* **`n = 35`**: recursion depth is fine, but the *number* is enormous. If the return type is:

  * `int`: overflow already happens at **13!**.
  * `long`: overflow happens at **21!** (because `20!` fits in `long`, `21!` doesn’t). So **35! overflows** badly.

---

### 2.3.2 Recursive function that returns `ln(n!)`

Use the identity:
[
\ln(n!) = \ln(n) + \ln((n-1)!)
]
with base case (\ln(0!) = \ln(1) = 0).

```java
public static double lnFactorial(int n) {
    if (n < 0) throw new IllegalArgumentException("n must be >= 0");
    if (n == 0) return 0.0;
    return Math.log(n) + lnFactorial(n - 1);
}
```

---

### 2.3.3 Sequence printed by `ex233(6)`

Code:

```java
public static void ex233(int n) {
    if (n <= 0) return;
    StdOut.println(n);
    ex233(n-2);
    ex233(n-3);
    StdOut.println(n);
}
```

Output (each on its own line), in order:

```
6
4
2
2
1
1
4
3
1
1
3
6
```

---

### 2.3.4 Value of `ex234(6)`

Code:

```java
public static String ex234(int n) {
    if (n <= 0) return "";
    return ex234(n-3) + n + ex234(n-2) + n;
}
```

Compute up:

* `ex234(1) = "11"`
* `ex234(2) = "22"`
* `ex234(3) = "3113"`
* `ex234(4) = "114224"`
* `ex234(6) = ex234(3) + "6" + ex234(4) + "6"`

So:

```
ex234(6) = "311361142246"
```

---

### 2.3.6 What does `gcd(gcd(a,b), gcd(c,d))` compute?

It computes the **greatest common divisor of all four numbers**:
[
\gcd(a,b,c,d)
]
(the largest integer that divides **a, b, c, and d**).

---

### 2.3.7 What does `gcdlike(p, q)` do?

```java
public static boolean gcdlike(int p, int q) {
    if (q == 0) return (p == 1);
    return gcdlike(q, p % q);
}
```

This is Euclid’s algorithm, but at the end it returns whether the final gcd equals 1.
So it returns **true exactly when**:
[
\gcd(p,q)=1
]
i.e., **p and q are relatively prime (coprime)**.

---

### 2.3.8 The `mystery(a, b)` function

```java
public static int mystery(int a, int b) {
    if (b == 0) return 0;
    if (b % 2 == 0) return mystery(a+a, b/2);
    return mystery(a+a, b/2) + a;
}
```

**Values:**

* `mystery(2, 25) = 50`
* `mystery(3, 11) = 33`

**What it computes:** for positive integers `a` and `b`, it computes:
[
a \times b
]
It’s “Russian peasant multiplication”: repeatedly double `a`, halve `b`, and add `a` when `b` is odd.

**Replace `+` with `*` and `return 0` with `return 1`:**
That becomes exponentiation by squaring, computing:
[
a^b
]

So the corresponding values would be:

* `mystery(2, 25) = 2^{25} = 33,554,432`
* `mystery(3, 11) = 3^{11} = 177,147`
